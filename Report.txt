Threats:
1. A man-in-the-middle (MITM) attack could allow an adversary to establish independent shared
secret/keys with the client and server separately and communicate over them, passing
messages on, but altering them as they go.
2. A MITM could rearrange the order in which messages are received by either
the client or the server, resulting in tampered traffic.
3. If our adversary wasn't bounded by time complexity/computing power, the symmetric key
could eventually be cracked.
4. The adversary could intercept insecure messages between the client and server.
5. The adversary could perform a Denial of Server attack on the server, continuously
sending tampered messages.
6. A MITM could send a prepareOutMessage which has bad values (extension of 1).
7. Messages could be sent to a client by an adversary posing as the server.
8. An adversary could crack the encryption key and send messages to the client
(extension of 7).

Solutions:
1. The use of RSAKey signatures where the shared key is signed by the server and then 
verified by the client will prevent this. The MITM's generated signature, created with the 
MITM and client's shared secret will be recognized as false by the client, then the shared
secrets will be deleted and the channel will be closed.
2. The use of a shared nonce generated by an identical PRGen in AuthEncryptor and 
AuthDecryptor for every individual message means that nonces will be generated in the same
order for both classes, meaning the messages have a predetermined order. So, if the MAC
generated by AuthDecryptor doesn't match the sent MAC, then the messages have been sent out
of order and authdecrypt returns null.
3. SecureChannel generates a new symmetric session key for every instance of SecureChannel
which means the session key isn't overused. If one is cracked, this also means that it will
not compromise any past communications as no symmetric key/nonce pair is every reused
(forward secrecy).
4. Once a secure channel has been established, messages are encrypted and sent meaning 
intercepted messages aren't human-readable/decipherable without the symmetric key.
5. Instead of closing the channel, we return null when decrypting messages which are either
out of order or have been tampered with by a MITM.
6. If message couldn't have been generated by prepareOutMessage, then processInMessage
returns null, and the signature verification will fail, and the client would close the
channel.
7. The inclusion of a MAC address, generated by a session key + nonce ensures that the
identity of the sender is the server. If the MAC address doesn't match, then authdecrypt
returns null.
8. The server uses separate keys for encryption and MAC so while the adversary could match
the encryption, the client would reject the MAC address and drop the message.
